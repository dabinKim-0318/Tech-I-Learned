
# 프로세스와 스레드 <a name = "outline"></a>
<details>
   <summary> Click 🙋‍♀️</summary>
<br />
 

### 📌프로세스  
- **프로세스는 컴퓨터 시스템의 작업 단위**로 태스크라고도 부름
  - 저장장치에 저장되어 있는 정적인 상태인 **프로그램이 운영체제로부터 프로세스 제어블록을 받아 메모리상에 올라오면 "프로세스"** 
  - 프로세스 제어 블록이 없으면 프로그램이 프로세스로 전환되지 못하며, 어떤 프로그램이 프로세스가 되었다는 것은 운영체제로부터 프로세스 제어 블록을 받았다는 의미
  - 프로그램 실행->프로세스
  - 자신만의 고유 공간과 자원을 할당받아 사용(코드/데이터/힙/스택)
  
### 📌멀티프로세스  
- 하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 것.
- 서로 다른 둘 이상의 프로그램을 실행하기 위해 각각의 프로세스를 생성하는 것

- 장점
  - 프로세스 중 하나에 문제가 생겨도 다른 프로세스에 영향을 주지 않아, 작업속도가 느려지는 손해정도는 생기지만 정지되거나 하는 문제는 발생하지 않는다.

- 단점
  - **각각 독립된 메모리 영역**을 가지고 있어, **작업량이 많을수록 Context Switching이 자주** 일어나서 **주소 공간의 공유가 잦을 경우 캐시 메모리 초기화 등 무거운 작업**이 자주 진행되면 **오버헤드**가 발생한다.
  

### 📌Context Switching
- Context Switching 이란 CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB로 읽어 레지스터에 저장하는 과정
- Context Switching은 주로 인터럽트가 발생하거나, 실행 중인 CPU 사용 허가 시간(Time Quantum)을 모두 소모하거나, I/O 입출력을 위해 대기해야 하는 경우 Context Switching이 발생한다

  - 만약 컴퓨터가 매번 하나의 Task만 처리할 수 있다면? 다음 Task를 처리하기 위해서 현재 Task가 끝날 때까지 기다려야한다
  - 다양한 사람들이 동시에 사용하는 것처럼 하기 위해서 Context Switching이 필요( CPU는 한번에 하나의 프로세스만 실행 가능)
     - 컴퓨터 멀티태스킹을 통해 빠른 반응속도로 응답 가능합니다.
     - 빠르게 Task를 바꾸면서 실행하기에 사람은 실시간처리가 되는 것처럼 보입니다.
     - CPU가 Task를 바꿔가며 실행하기 위해 Context Switching이 필요하게 되었습니다.
  
### 📌Context Switching 오버헤드

- 프로세스들의 시간 할당량은 시스템 성능의 중요한 역할을 한다. 시간 할당량이 적을수록 사용자 입장에서는 여러 개의 프로세스가 거의 동시에 수행되는 느낌을 갖지만 Context Switching의 수가 늘어난다. 프로세스의 실행을 위한 부가적인 활동을 **오버헤드**(간접 부담 비용)이라고 하는데, 이 또한 Context Switching 수와 같이 늘어나게 된다. 
- 시간 할당량이 적어지면 : Context Switching 수, 오버헤드가 증가하지만 여러 개의 프로세스가 동시에 수행되는 느낌을 갖는다.
- 시간 할당량이 커지면 : Context Switching 수, 오버헤드가 감소하지만 여러 개의 프로세스가 동시에 수행되는 느낌을 갖지 못한다.

- **프로세스를 수행하다가 I/O event가 발생하여 BLOCK 상태로 전환시켰을 때, CPU가 그냥 놀게 놔두는 것보다 다른 프로세스를 수행시키는 것이 효율적**이므로, CPU에 계속 프로세스를 수행시키도록 하기 위해서 다른 프로세스를 실행시키고 Context Switching을 할 때 Overhead가 발생한다다.

- 전체적으로 봤을 때 이익이 되니까 overhead를 감수하더라도 Context Switching을 하는 거고 그래서 운영체제가 CPU를 관리하는 것. 사용자가 너무 기다리지 않게 관리하기 위해서 반드시 해줘야 하는게 Context Switching이고 이것이 대표적으로 운영체제가 하는 CPU관리 한다.
 
***
   
### 📌스레드
- 둘 이상의 실행 흐름이 필요해 프로세스를 생성하는 작업은 부담스러움
    - why? 많은 수의 프로세스 생성은 빈번한 컨텍스트 스위칭으로 이어져 성능에 영향을 미치기 때문
    - 해결방법은? 저장하고 복원하는 컨텍스트 정보의 개수를 줄이면 된다. 즉 컨텍스트 정보란 프로세스 상테 정보와 관련이 있으므로 →프로세스 상태 정보를 줄여야 한다는 것이다.
- 컨텍스트 스위칭이 필요한 이유는?
    - 프로세스들이 독립되어 있기 때문
    - if) 두 프로세스가 완전히 별개가 아닌 반을 공유하는 구조라면?
    - 컨텍스트 스위칭 발생 시 저장 및 복원 정보도 반으로 줄게됨
    - →스레드가 등장
- 해결책:스레드
    - 별개의 프로그램이라면 독립된 프로세스 구조가 필요함
    - 하지만, 하나의 프로그램 내 둘 이상의 실행흐름을 만들경우, 모든것을 독립할 필요가 x
   
- **CPU 스케줄러가 CPU에 작업을 요청하는 실행단위=프로세스 안에서 실행되는 흐름단위**
  - 운영체제가 프로세스 제어블록을 생성하고 작업에 필요한 메모리 영역을 확보한 후 준비된 프로세스를 준비큐에 삽입  
  ->프로세스가 생성되면 CPU스케줄러는 프로세스가 해야하는 일을 CPU에 전달하고 실제 작업은 CPU가 수행  
  ->이때 CPU스케줄러가 CPU에 전달하는 일 하나는 "스레드"  
  - 스레드는 스택영역만 따로 할당받고 나머지 영역은 스레드끼리 서로 공유

     
 
### 📌멀티스레드
- 예전엔 여러 작업을 동시에 처리하기 위해 fork() 시스템 호출로 프로세스를 전환하는 방법을 이용했음 = 멀티태스크 ex) 워드랑 프린트 스풀러는 독립적으로 작동하다가 필요할 때 출력할 데이터를 프로세스간 통신을 이용해 주고받음     
  ->프로세스의 정적영역(코드/데이터) 영역 메모리 중복 
  ->비슷한 일을 하는 여러 프로세스를 만들지 말자   
  ->정적영역 공유면서 여러개의 일을 하나의 프로세스 내에서 하자   
  ->CPU가 여러 스레드 조금씩 돌면서 병렬적으로 작업  
  ->코드 영역등을 함께 공유해서 자원 낭비 막고 효율성 향상!!! 

- 멀티스레드 장점
    - **자원공유**: 프로세스가 가진 자원을 모든 스레드가 공유->작업 원활   
    - **응답성 향상**: 다른 스레드가 작업을 계속하여 사용자의 작업 요구에 빨리 응답 가능   
   ex) 채팅+파일 주고받기 / 워드 작성+틀린글자 찾아줌 / 비디오 플레이어 입출력(재생파일 저장장치로부터 가져옴)+영상재생   
  
 - 멀티스레드 단점
    - **독립X**: 모든 스레드가 자원공유하니까 한 스레드에 문제 발생하면 전체 프로세스에 영향  
  EX)익스플로러:프로세스1+멀티스레드 / 크롬:멀티태스크 -> 다른 화면 종료되어도 전체종료X
    - **동기화**:자원 공유로 인한 일치 문제 등
    - **오버헤드**: 싱글 코어 멀티 스레딩은 스레드 생성 시간이 오히려 오버헤드로 작용해 단일 스레드보다 느리다.
 
 - 안전성 Critical Section 대비함
   - 하나의 스레드가 공유 데이터 값을 변경하는 시점에 다른 스레드가 그 값을 읽으려할 때 발생하는 문제를 해결하기 위한 동기화 과정
### 📌싱글스레드
- 하나의 프로세스에서 오직 하나의 스레드로만 실행
- 장점
  - **문맥 교환X**: 문맥 교환은 여러 개의 프로세스가 하나의 프로세서를 공유할 때 발생하는 작업으로 많은 비용을 필요로 한다.

  - **동기화X**: 여러 개의 스레드가 프로세스의 자원을 공유할 경우, 각 스레드가 원하는 결과를 얻게 하려면 공용 자원에 대한 접근을 제어해야 한다. 쉽게 말해서, 모든 스레드가 일정 자원에 동시에 접근하거나, 똑같은 작업을 실행하려는 경우, 에러가 발생하거나 원하는 값이 나오지 않는다. 그래서, 스레드들이 동시에 같은 자원에 접근하지 못하도록 제어해줘야만 한다. 이 작업은 프로그래머에게 많은 노력을 요구하고 비용을 발생시킨다.

- 단점
  - **연산량이 많은 작업을 하는 경우, 그 작업이 완료되어야 다른 작업을 수행**할 수 있다
  EX)서버 통신 완료 되어야 UI클릭 가능

  - **에러 처리를 못하는 경우 멈춘다.**
멀티 스레드 모델은 에러 발생 시 새로운 스레드를 생성하여 극복한다. 다만, 새로운 스레드 생성이나 놀고 있는 스레드 처리에 비용이 발생한다.
   
***
   
### 📌멀티스레드 vs 싱글스레드

- **단순히 CPU만을 사용하는 계산작업이라면, 오히려 멀티스레드보다 싱글스레드로 프로그래밍하는 것이 더 효율적**이다.
=> a) 두 개의 작업을 하나의 스레드로 처리하는 경우 VS b) 두 개의 스레드로 처리하는 경우
b의 경우는 짧은 시간 동안 2개의 스레드가 번갈아가면서 작업을 수행한다. 그래서 동시에 두 작업이 처리되는 것과 같이 느끼게 된다.
하지만, 오히여 두 개의 스레드로 작업한 시간이 싱글스레드로 작업한 시간보다 더 걸릴 수도 있는데, 그 이유는 **스레드 간의 작업전환(context switching)에 시간이 걸리기 때문**이다.
다시 말해서, 단순히 CPU만을 사용하는 작업은 싱글 스레드가 멀티 스레드보다 빠르다.
 
### 📌스레드 vs 프로세스
-  프로세스는 운영체제의 **작업단위**, 스레드는 CPU 스케줄러가 CPU에 작업을 요청하는 **실행단위** 
-  프로세스는 **자신만의 고유 공간과 자원 할당** 받음 / 스레드는 **다른 스레드와 자원 공유**
- 프로세스는 완전히 독립된 두 개의 프로그램 실행을 위해 사용됨
- 스레드는 하나의 프로그램 내 둘 이상의 프로그램 흐륾을 만들어 내기 위해 만들어진 것
- 스레드는 프로세스와 다르게 공유하는 상태정보들이 있음 →이것이 스레드의 컨텍스트 스위칭을 빠르게 하는 요인    
***   
 
### 👉예상질문) 스레드의 등장배경은?
둘 이상의 실행흐름이 필요해 프로세스를 생성하는 작업은 빈번한 컨텍스트 스위칭으로 이어져 성능에 영향을 미치게 됩니다.
이러한것을 해결할 수 있는 방법은 저장 및 복원해야하는 컨텍스트의 정보의 수를 줄이면 됩니다.만약 두 프로세스가 완전
히 별개가 아닌 일정량을 공유하는 구조가 될 경우 성능 저하의 문제점을 보완할 수 있어 스레드가 등장하게 되었습니다.
   
### 👉예상질문) 멀티 프로세스로 처리 가능한 걸 굳이 멀티 스레드로 하는 이유는?
프로세스를 생성하여 자원을 할당하는 시스템 콜이 감소함으로써 자원의 효율적 관리가 가능 프로세스 간의 통신(IPC)보다 스레드 간의 통신 비용이 적어 작업들 간 부담이 감소 대신, 멀티 스레드를 사용할 때는 공유 자원으로 인한 문제 해결을 위해 '동기화'에 신경써야 한다.   
   
### 👉예상질문) 멀티 프로세스를 사용해야 하는 경우와 멀티 스레드를 사용해야 하는 경우를 설명해보세요
멀티 프로세스를 사용해야 하는 경우는  서로 다른 둘 이상의 프로그램을 실행할때 입니다. 멀티 스레드를 사용해야 하는 경우는 하나의 프로그램이 두 가지 이상의 일을 동시에 처리해야 할 때 입니다.   
   
### 👉예상질문) 이런 상태일때는 무슨 스레드 쓸까?
  </details>

<br>

# 사용자 수준 스레드, 커널 수준 스레드 <a name = "reason"></a>
<details>
   <summary> Click 🙋‍♀️</summary>
<br />

### 📌스레드 종류
스레드는 운영체제에 따라  
1.사용자 수준 스레드 2.커널 수준 스레드 3.혼합형 스레드
   
### 📌사용자 수준 스레드
- 스레드와 관련된 모든 행위를 스레드 관련 라이브러리를 이용해서 사용자 영역에서 하는 스레드
- 스레드 관련 라이브러리는 스레드 생성, 종료, 스레드 간 메시지 전달, 스레드 스케줄링, 컨텍스트 등 정보 보관
- 스레드 관련 모든 행위를 "사용자 영역"에서 하기 때문에 커널은 스레드의 존재를 모르고 개입도 안함
   
- 장점
   - 높은 이식성: 커널에 독립적으로 스케줄링 할 수 있어, 모든 운영체제에 적용 가능
   - 스케줄링을 위해 커널을 호출하지 않으며로 커널영역으로 전환하는 오버헤드가 줄어듬
   
- 단점
   - 커널이 다른 스레드의 존재를 알지 못하므로 하나의 스레드가 블락되면 다른 프로세스에게 CPU를 뺏김
   - 스레드들을 보호 못해줌: 커널에서 이루어지는 스레드 간 보호 방법을 사용 못한다. 스레드 라이브러리에서 제공해주면 가능
   
   
### 📌커널 수준 스레드
- 커널이 스레드와 관련된 모든 작업을 관리하는 형태의 스레드
   
- 장점
   - 하나의 프로세스에 여러 스레드들이 동시에 실행 가능. 하나의 스레드가 대기 상태가 되어도 다른 스레드 실행 가능
- 단점
   - 커널이 모든 프로세스와 스레드에 대한 정보를 유지하고 있어야 하니까 오버헤드가 커짐
   
 ### 📌혼합형 스레드
- 커널 수준 스레드의 단점(스레드의 수가 제한된다)과 유저 수준 스레드의 단점(시스템 콜이 일어날 때마다 다른 스레드가 멈춘다)를 보완하기 위해 제시된 방법
- 사용자 수준 스레드와 커널 스레드 사이에 경량 프로세스 스레드를 둔 형태   
- 사용자 수준 스레드 하나가 시스템 콜의 호출에 의해 중지되더라도, 다른 경량 프로세스 스레드에서 동작하던 스레드는 계속 동작함
- 효율성과 유연성을 모두 잡을 수 있게 됨   
   
 </details>

<br>
 
 
# 스케줄러<a name = "reason"></a>
<details>
   <summary> Click 🙋‍♀️</summary>
<br />
   
 ### 📌스케줄러
 - 프로세스가 생성되고 종료될때까지 **모든 상태 변화를 조정**하는 일을 함  
   왜? CPU를 잘 쓰려고. 프로세스를 잘 배정해서!
   
### 📌스케줄링 구분
- CPU스케줄러도 관리의 범주를 나누어 스케줄링 하는데, "규모"에 따라 장기, 중기, 단기 스케줄링으로 구분

### 📌장기 스케줄러
- 프로세스에게 메모리같은 각종 자원을 줄까? 말까?를 관리하기 때문에 메모리에 올라갈 프로세스 수도 제어해야한다.
- 메모리에 올라갈 프로그램 수를 결정하니까 실행 가능한 프로세스의 수를 조절하는 역할
- 하지만 오늘날 우리가 사용하는 시스템에는 장기 스케줄러가 없다! 프로그램이 시작되면 곧바로 메모리에 올라간다= 프로그램 100개 실행하면 전부 메모리에 올라각서 CPU얻기를 기다리는 준비 상태가 된다.
- 그럼 우리가 사용하는 프로그래밍의 멀티 프로그래밍을 제어하는건 누구? =? 중기 스케줄러
- 어떤 프로세스가 메모리에 올라가고 싶은데 메모리 줄까 말까를 "중기 스케줄러"가 결정
### 📌중기 스케줄러   
메모리 공간이 부족해서 시스템 과부하가 걸리면 프로세스 통째로 메모리에서 디스크로 쫒아내고 "보류(일시정지)" 상태로 보냄
 
### 📌단기 스케줄러  
 - 준비상태의 프로세스 중 어떤걸 실행상태로 옮길까? 등을 결정
 - 프로세스에 CPU를 주는 문제를 담당->잦은 스케줄링 필요해서 매우 빨라야함
 
### 📌CPU 스케줄링이 필요한 경우
- I/O요청하는 시스템 콜: 실행->대기 
- 타임아웃/인터럽트: 실행->준비  
- I/O완료 후 인터럽트: 대기->준비
   
### 📌CPU 스케줄링 알고리즘
- 스케줄링 알고리즘은 비선점, 선점형 알고리즘으로 나뉜다 
- 선점형: CPU할당 받아 실행중이어도 운영체제가 CPU 강제로 뺏기 가능 =>라운드로빈, SRT , 다단계 ~
- 비선점형: 작업이 끝날때까지 CPU안놔줌 => FCFS, SJF, HRN
- 둘다가능: 우선순위 스케줄링
    
 </details>
<br>

# 인터럽트<a name = "reason"></a>
<details>
   <summary> Click 🙋‍♀️</summary>
<br />

- 입출력장치랑 상호작용하는 3가지 방법
#### 1. 폴링방식: 초기의 컨퓨터 시스템에는 주변 장치가 많지 않았어서 CPU가 주변 입출력 장치들(키보드, 센서, LCD 등)에서의 변화를 지속적으로 계속 확인하고 그에 따라 프로그램을 처리하는 방식을 말한다.
   - EX) 프로그램은 쉽게 구현할 수 있지만 예를 들어 컴퓨터의 키보드를 폴링방식으로 구현한다고 생각해보자. 컴퓨터로 영화를 보고 있는데도 키보드를 치고 있는지 아닌지 계속 확인하는 작업을 한다면 CPU의 성능을 제대로 활용할 수 없다. 하지만 아두이노, AVR 등에서 간단한 프로젝트를 구현할 때는 코드를 작성하기 간편하다는 장점 때문에 폴링 방식을 사용하기도 한다. 폴링 방식이 꼭 나쁜 건 아니다. 드론을 만들 때 자세 센서에서 계속 값을 읽어와야하는데, 폴링 방식으로 자세 센서와 상호작용했다.
   - 장점: 구현이 간단
   - 단점: CPU가 입출력장치까지 관여해야하므로 작업 효율 떨어짐 / 한 루프를 다 돌아야지만 상태 변화를 확인할 수 있음
   
#### 2. 인터럽트
   - 입출력 관리자가 CPU에게 보내는 완료신호
   - 예외현상이 발생해 CPU의 정상적인 동작을 방해한 상태
   - 인터럽트 방식은 하드웨어 지원을 받아야하는 제약이 있지만 폴링에 비해 신속대응이 가능
   - 실시간 대응이 필요할 때 필수적 기능
   - 발생시기를 예측하기 힘든 경우에 컨트롤러가 가장 빠르게 대응할 수 있는 방법
   
#### 3. DMA(Direct Memory Access)
   - 폴링은 프로그램에 의한 입출력 방식이여서 CPU가 계속 주변장치를 감시하기 때문에 CPU의 효율이 떨어진다고 했다. 이런 점을 개선하기 위해 CPU개입없이 주변장치와 상호작용하는 DMA(Direct Memory Access)가 개발되었다.
   - 그럼 CPU개입이 적은 인터럽트를 사용하면 되지 않을까?
   - 인터럽트를 사용하더라도 여전히 CPU는 데이터 전송을 하기위해 개입하게 되고, 입출력하는 시간이 길어지게 되면 CPU는 입출력하는 동안 다른 일을 못하게 된다.
   - 그럼 CPU는 무엇을 하면 될까? CPU는 DMAC(DMA controller)에게 입출력 관련 정보만 주고 다른일을 계속 하면된다.
   - 입출력 정보에는 뭐가 있을까? CPU는 DMAC에게 어떤 source를 보내는지, 목적지는 어딘지, 얼마만큼 보내는지를 알려주고 언제 전송을 시작하고 어떤 방식으로 할지만 알려주면 DMAC가 알아서 데이터를 전송해준다. 
   - 전송이 끝나면 DMAC는 CPU에게 인터럽트를 발생시킨다. 결론적으로 CPU는 전송의 시작과 끝에만 관여하게 되고 직접적이 데이터 전송은 DMAC가 하게 되는 것이다.
   
### 📌인터럽트 처리 과정
cpu 실행하고 있는 도중에 입출력 장치에서 필요할 때 마다 즉각적으로 CPU에게 인터럽트 신호를 전송하게 된다. 해당 인터럽트가 요청한 작업을 실행하기 위해 하고있는 동작을 멈추고 ISR(인터럽트 처리 루틴)으로 이동한다. ISR이 완료되면 CPU는 수행을 멈춘 곳으로 되돌아가 중지된 작업을 계속한다. 
   
   ![다운로드](https://user-images.githubusercontent.com/84564695/187033468-7d955e94-a877-43e9-99ed-852b6df6c14a.png)

   
- 평소에는 노란색 LED와 파란색 LED를 번갈아가며 1초마다 깜빡이다가 스위치를 누르면 1초간 빨간색 LED를 켜고 다시 노란색, 파란색 LED를 계속 깜빡이게 개발한다고 생각해보자. 이 상황에서 노란색 LED와 파란색 LED가 깜빡이는 것은 순차적이고 반복적인 작업이지만 스위치가 눌러지는 예외 상황이 발생하면 빨간색 LED를 즉시 켜야 한다. 

- 이처럼 **반복적이고 순차적인 작업이 아닌 예외 적으로 즉시 처리되기를 원하는 명령이나 동작을 인터럽트 또는 예외 처리**라고 부른다.

 
인터럽트가 발생하게 되면 일단,


1. 실행중인 작업을 중단하고 현재 태스크의 Context(레지스터 값)을 스택에 저장한다. 
현재 프로그램 상태(PC, SR)를 저장하는 이유는 인터럽트 처리를 끝내고 작업을 원상 복구하기 위해서다. 
예를 들어, 노란색 LED를 켜고 나서 인터럽트가 발생하여 빨간색 LED를 켰다. 인터럽트가 발생했을 때, 그다음 켜야 할 색이 파란색이란 것을 저장했었어야 빨간색 LED 다음에(인터럽트를 처리하고) 파란색 LED를 켜야 한다는 것을 알 수 있을 것이다. 
이렇게 인터럽트 요청에 의해 기존의 프로세스의 상태를 저장하고 CPU가 우선순위의 프로세스를 수행하도록 새로운 프로세서의 상태, 레지스터값을 교체하는 것을 Context Switching이라고 한다. 

 2. 인터럽트를 처리하기 위해서 인터럽트 벡터 테이블을 참조하여 ISR 주소 값을 얻는다. 
인터럽트 벡터 테이블이란 인터럽트 핸들러(ISR) 주소를 저장하고 있는 테이블을 말하고, 인터럽트 핸들러(Interrupt Service Routine)는 인터럽트를 처리하기 위한 코드이고, 함수의 형태를 가지고 있다. 

3. 인터럽트 핸들러를 실행한다. 

4. 원래 작업으로 돌아오기위해 아까 스택에 저장해두었던 Context를 복원한다. 

5. PC값을 이용해 인터럽트 발생 전 수행하던 작업을 계속 진행한다 .


### 📌인터럽트 종류
 #### 외부 인터럽트 VS 내부 인터럽트 
 - 외부 인터럽트: 입출력 장치, 타이밍 장치. 전원등 외부적인 요인으로 발생
    
    ex)전원 이상, 입출력 인터럽트(키보드, 프린터기 등), 타이머 인터럽트
    
- 내부 인터럽트: Trap이라고 불림, 잘못된 명령이나 데이터를 사용할 때 발생
    
    ex)0으로 나누기 발생, 오버플로우, 명령어를 잘못 사용한 경우(Exception)
    
 #### 소프트웨어 인터럽트
- 소프트웨어가 발생시키는 인터럽트. 소프트웨어(사용자 프로그램)가 스스로 인터럽트 라인을 세팅함
- 프로그램 처리 중 명령의 요청에 의해 발생
- 대표적인 형태는 프로그램에서 감시 프로그램 호출(SVC) 호출
- SVC(SuperVisor Call)
    - 명령어 수행시 문제가 생겼을 때, **프로세서에게 컴퓨터의 제어권을 OS의 감시자(supervisor)에게 넘기라는 명령**
    - 사용자가 프로그램을 실행시키거나 감시프로그램(Supervisor)을 호출하는 동작을 수행하는 경우
    - 복잡한 입출력 처리를 하는 경우
    - system call
 </details>

<br>

# 프로세스 동기화<a name = "reason"></a>

<details>
   <summary> Click 🙋‍♀️</summary>
<br />


 </details>

<br>

# 시스템 콜<a name = "reason"></a>
<details>
   <summary> Click 🙋‍♀️</summary>
<br />


 </details>

<br>
